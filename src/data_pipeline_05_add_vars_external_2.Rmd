---
title: "R Notebook"
output: html_notebook
---

## Create CENSUS block variable, geoid_blockce

By adding a geoid that goes down to the census block level, we can associate demographic data collected by the Census with each property.

### Get blocks

THIS ALL NEEDS TO BE UPDATED

```{r}
get_blocks <- function(geoid_st = "51") { sql <- paste0("select geoid_cnty, p_id_iris_frmtd, geometry from corelogic_usda.broadband_variables_tax_2020_06_27_unq_prog where property_centroid_longitude IS NOT NULL AND geoid_cnty LIKE '", geoid_st,"%'") con <- get_db_conn() print(paste("getting", geoid_st, "rows")) db_rows_blk <- st_read(con, query = sql) DBI::dbDisconnect(con) blk_map_path <- paste0("/home/ads7fg/sdad/projects_data/usda/bb/original/censusblocks/blocks_TIGER2018_sf_RDS/tl_2018_", geoid_st, "tabblock10.RDS") print(paste("getting", geoid_st, "blocks")) blk_map <- readRDS(blk_map_path) %>% sf::st_transform(4326) print(paste("getting", geoid_st, "interesection")) int <- sf::st_intersects(db_rows_blk, blk_map) int2 <- as.integer(as.character(int)) db_rows_blk$geoid_blk <- as.character(blk_map$GEOID10[unlist(int2)]) print(paste("saving", geoid_st, "results")) file_path <- paste0("data/working/sales_with_blk", geoid_st, ".RDS") saveRDS(db_rows_blk, file_path) rm(blk_map) }

geoids_st <- tigris::states() geoids_st$geometry <- NULL geoids_st <- geoids_st[!geoids_st$GEOID %in% c("78", "69", "60", "72", "12", "51", "54"), c("GEOID")]

library(doParallel)

cl <- makeForkCluster(6, outfile = "src/parlog") doParallel::registerDoParallel(cl)

geoids_st_test <- geoids_st[21:49] res <- foreach(i = 1:length(geoids_st_test)) %dopar% { get_blocks(geoids_st_test[i]) }

parallel::stopCluster(cl)

file_paths <- list.files("data/working/", pattern = "sales_with_blk*", full.names = TRUE) con <- get_db_conn() dat <- readRDS(file_paths[1]) sf::dbWriteTable(con, c("corelogic_usda", "sales_with_blk"), dat) rm(dat) DBI::dbDisconnect(con)

library(doParallel) library(sf) library(RPostgreSQL) library(data.table)

cl <- makeForkCluster(6, outfile = "src/parlog") doParallel::registerDoParallel(cl)

file_paths_2 <- file_paths[2:45] res <- foreach(i = 1:length(file_paths_2)) %dopar% { con <- get_db_conn() print(paste("reading", file_paths_2[i])) dat <- readRDS(file_paths_2[i]) print(paste("writing", file_paths_2[i])) sf::dbWriteTable(con, c("corelogic_usda", "sales_with_blk"), dat, append = TRUE) rm(dat) DBI::dbDisconnect(con) }

parallel::stopCluster(cl)
```

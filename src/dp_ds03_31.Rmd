---
title: "Add Variables by Transorming Existing Columns"
output: 
  html_document:
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  eval=FALSE
)
```

------------------------------------------------------------------------




## FCC 


### Form 477

-   Get the maximum speed per census block where data is available in
    FCC data
-   Compare that maximum speed to our eligibility threshold

#### 2014 Data

<!-- Note that we tried the following thresholds for 2014. -->

<!-- -   10/1 -->
<!-- -   4/1 -->
<!-- -   4/768 -->
<!-- -   5 (upload + download) ** selected -->

For the year 2014, we used a combined speed threshold using the maximum advertised download and upload speeds. The combined value needed to be equal or greater than 5 Mbps. 

```{r include = FALSE}
# fcc_2014_block_max <- fcc_2014 %>%
#   group_by(StateAbbr, BlockCode) %>%
#   summarise(MaxAdDown_ = max(MaxAdDown),
#             MaxAdUp_ = max(MaxAdUp)) %>%
#   mutate(speed_elig_down = ifelse(MaxAdDown_ >= 10, 0, 1),
#          speed_elig_up = ifelse(MaxAdUp_ >= 1, 0, 1),
#          speed_inelig = ifelse(MaxAdDown_ >= 10 & MaxAdUp_ >= 1, 1, 0),
#          speed_elig = ifelse(MaxAdDown_ >= 10 & MaxAdUp_ >= 1, 0, 1))

# #threshold of 4/1
# fcc_2014_block_max <- fcc_2014 %>%
#   group_by(StateAbbr, BlockCode) %>%
#   summarise(MaxAdDown_ = max(MaxAdDown),
#             MaxAdUp_ = max(MaxAdUp)) %>%
#   mutate(speed_elig_down = ifelse(MaxAdDown_ >= 4, 0, 1),
#          speed_elig_up = ifelse(MaxAdUp_ >= 1, 0, 1),
#          speed_inelig = ifelse(MaxAdDown_ >= 4 & MaxAdUp_ >= 1, 1, 0),
#          speed_elig = ifelse(MaxAdDown_ >= 4 & MaxAdUp_ >= 1, 0, 1))

# #threshold of 4/768
# fcc_2014_block_max_ <- fcc_2014 %>%
#   group_by(StateAbbr, BlockCode) %>%
#   summarise(MaxAdDown_ = max(MaxAdDown),
#             MaxAdUp_ = max(MaxAdUp)) %>%
#   mutate(speed_elig_down = ifelse(MaxAdDown_ >= 4, 0, 1),
#          speed_elig_up = ifelse(MaxAdUp_ >= 0.768, 0, 1),
#          speed_inelig = ifelse(MaxAdDown_ >= 4 & MaxAdUp_ >= 0.768, 1, 0),
#          speed_elig = ifelse(MaxAdDown_ >= 4 & MaxAdUp_ >= 0.768, 0, 1))

# saveRDS(fcc_2014_block_max, "/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fcc_2014_block_maxspdelig.RDS")
# saveRDS(fcc_2014_block_max, "/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fcc_2014_block_maxspdelig_threshold_4_1.RDS")
# saveRDS(fcc_2014_block_max_, "/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fcc_2014_block_maxspdelig_threshold_4_768.RDS")

```

This is the code I used - Josh may have a version of this somewhere. 

```{r}
# #threshold of 3 mbps (download + upload)
fcc_2014_block_max_ <- fcc_2014 %>%
  group_by(StateAbbr, BlockCode) %>%
  summarise(MaxAdDown_ = max(MaxAdDown),
            MaxAdUp_ = max(MaxAdUp)) %>%
  mutate(total_speed = MaxAdDown_ + MaxAdUp_,
         speed_elig_down = NA, #ifelse(MaxAdDown_ >= 4, 0, 1),
         speed_elig_up = NA, #ifelse(MaxAdUp_ >= 0.768, 0, 1),
         speed_inelig = ifelse(total_speed < 3, 1, 0),
         speed_elig = ifelse(total_speed >= 3, 0, 1))

saveRDS(fcc_2014_block_max_, "/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fcc_2014_block_maxspdelig_threshold_total3.RDS")

```

#### 2018 DATA


```{r}
fcc_2018 <-
read.csv("/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fbd_us_without_satellite_dec2018_v2.csv")

fcc_2018_block_max <- fcc_2018 %>% group_by(StateAbbr, BlockCode) %>%
summarise(MaxAdDown_ = max(MaxAdDown), MaxAdUp_ = max(MaxAdUp)) %>%
mutate(speed_elig_down = ifelse(MaxAdDown_ >= 10, 0, 1), speed_elig_up
= ifelse(MaxAdUp_ >= 1, 0, 1), speed_inelig = ifelse(MaxAdDown_ >=
10 & MaxAdUp_ >= 1, 1, 0), speed_elig = ifelse(MaxAdDown_ >= 10 &
MaxAdUp_ >= 1, 0, 1))

# saveRDS(fcc_2018_block_max, "/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/fcc_availability/fcc_2018_block_maxspdelig.RDS")

```

## USDA 

### Non-Rural Areas 2010-2020

Took shapefile

* intersected against counties to return TF - get counties where T - didn't use
* made boundaries valid - didn't use 

1. intersection against state (returns polygons)
2. intersection against tract 
3. intersection against block 

```{r}
### entire thing https://github.com/uva-bi-sdad/rural_broadband/blob/dtmn_elig/src/eligibility/usda_nonrural_areas_map_manip.Rmd

for (i in 4:nrow(files_to_intersect_)) {
  print(files_to_intersect_$state[i])
  options(tigris_use_cache = TRUE)
  tracts <- tigris::tracts(state = files_to_intersect_$state[i])
  tracts <- tracts %>% left_join(us_counties_x_urban, by = c( "STATEFP",  "COUNTYFP"))
  rural_cty_tracts <- tracts %>% filter(county_nonrural != 1 | is.na(county_nonrural))
  
  
  
  if(nrow(rural_cty_tracts) != nrow(tracts) ) {
    # INTERSECTION WITH TRACTS - get tract level polygons
    nonrural_cty_tracts <- tracts %>% filter(county_nonrural == 1)
    nonrural <- readRDS(files_to_intersect_$nr_path[i])
    nonrural_cty_tracts_polygons <- st_intersection(nonrural_cty_tracts, nonrural)
    saveRDS(nonrural_cty_tracts_polygons, file = paste0("/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/RECONNECT_NON_RURAL_working/nonruralstate_2018_", files_to_intersect_$state[i],"_nonruraltracts_polygons.RDS"))
    
    # INTERSECT TRACT POLYGONS WITH BLOCKS - get block level YES/NO nonrural
    blocks <- readRDS(files_to_intersect_$cb_paths[i])
    blocks <- blocks %>% left_join(us_counties_x_urban, by = c("STATEFP10" = "STATEFP", "COUNTYFP10" = "COUNTYFP"))
    rural_cty_blocks <- blocks %>% filter(county_nonrural != 1|is.na(county_nonrural))
    nonrural_cty_blocks <- blocks %>% filter(county_nonrural == 1)
    
    blocks_nonrural_tract_vector <- st_intersects(nonrural_cty_blocks, nonrural_cty_tracts_polygons)
    nonrural_cty_blocks$nonruralTF <- blocks_nonrural_tract_vector %>% lengths > 0 
    
    blocks <- rbind(rural_cty_blocks %>% mutate(nonruralTF = 0), nonrural_cty_blocks)
    
    saveRDS(blocks, paste0(savepath, savepath_1, "blocks_2018_nonruralTF_sf_", files_to_intersect_$state[i], ".RDS"))
    
    blocks_df <- blocks %>% as.data.frame() %>% select(STATEFP10, COUNTYFP10, TRACTCE10, BLOCKCE10, GEOID10, NAME10, nonruralTF)
    saveRDS(blocks_df, paste0(savepath, savepath_2, "blocks_2018_nonruralTF_df_", files_to_intersect_$state[i], ".RDS"))
  }
  
  if(nrow(rural_cty_blocks) == nrow(blocks) ) {
    print(files_to_intersect_$state[i])
    print("has no non-rural counties")
  }
  
}
```


### Protected Borrowers

```{r}
protborr <- sf::st_read("/project/biocomplexity/sdad/projects_data/project_data/usda/rural_broadband/rus_broadband_servicearea/ProtectedBorrowers04222019.shp")
protborr <- protborr %>% st_transform(st_crs(usa_blocks_speed_rural))
blocks_criteriaXprotborr_VECTOR <- st_intersects(usa_blocks_speed_rural, protborr) 
usa_blocks_speed_rural$protborr_inelg_vec <- blocks_criteriaXprotborr_VECTOR %>% lengths >0 

```

### USDA CAF II Spectrum Auction Winners

```{r}
caf2auctionwinners <- st_read("/project/biocomplexity/sdad/projects_data/usda/bb/original/Protected_bb_borrower_service_areas/Auction903_April2019.shp")
caf2auctionwinners <- caf2auctionwinners %>% st_transform(st_crs(usa_blocks_speed_rural))
blocks_criteriaXcaf2winners_VECTOR <- st_intersects(usa_blocks_speed_rural, caf2auctionwinners) 
usa_blocks_speed_rural$caf2_inelg_vec <- blocks_criteriaXcaf2winners_VECTOR %>% lengths >0 
```

